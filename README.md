# tinywasm/dom
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by devflow from github.com/tinywasm/devflow"></a>
<!-- END_SECTION:BADGES_SECTION -->

> **Ultra-minimal DOM & event toolkit for Go (TinyGo WASM-optimized).**

tinywasm/dom provides a minimalist, WASM-optimized way to interact with the browser DOM in Go, avoiding the overhead of the standard library and `syscall/js` exposure. It is designed specifically for **TinyGo** applications where binary size and performance are critical.

## üöÄ Features

*   **Elm-Inspired Architecture**: Component-local state with explicit updates (Model ‚Üí Update ‚Üí View)
*   **Fluent Builder API**: Chainable methods for concise, readable code
*   **Hybrid Rendering**: Choose DSL for dynamic components or string HTML for static ones
*   **TinyGo Optimized**: Avoids heavy standard library packages to keep WASM binaries <500KB
*   **Direct DOM Manipulation**: No Virtual DOM overhead. You control the updates.
*   **ID-Based Caching**: Efficient element lookup and caching strategy
*   **Memory Safe**: Automatic event listener cleanup on `Unmount`
*   **Lifecycle Hooks**: `OnMount`, `OnUpdate`, `OnUnmount` for fine-grained control

## üì¶ Installation

```bash
go get github.com/tinywasm/dom
```

## ‚ö° Quick Start

### Example 1: Dynamic Component (Elm Pattern)

Counter component with state management:

```go
//go:build wasm

package main

import (
	"github.com/tinywasm/dom"
	"github.com/tinywasm/fmt"
)

// Model (state)
type Counter struct {
	dom.BaseComponent
	count int
}

// View (rendering)
func (c *Counter) Render() dom.Node {
	return dom.Div().
		ID(c.GetID()).
		Class("counter").
		Append(
			dom.Button().
				Text("-").
				OnClick(c.Decrement),
		).
		Append(
			dom.Span().
				Class("count").
				Text(fmt.Sprint(c.count)),
		).
		Append(
			dom.Button().
				Text("+").
				OnClick(c.Increment),
		).
		ToNode()
}

// Update (state mutations)
func (c *Counter) Increment(e dom.Event) {
	c.count++
	c.Update() // Explicit re-render
}

func (c *Counter) Decrement(e dom.Event) {
	c.count--
	c.Update()
}

// Lifecycle (optional)
func (c *Counter) OnMount() {
	fmt.Println("Counter mounted with ID:", c.GetID())
}

func main() {
	counter := &Counter{count: 0}
	dom.Render("app", counter)
	select {}
}
```

### Example 2: Static Component (String HTML)

For simple, static content use string HTML (smaller binary):

```go
type Header struct {
	dom.BaseComponent
}

func (h *Header) RenderHTML() string {
	return `<header class="app-header">
		<h1>My Application</h1>
	</header>`
}

func main() {
	header := &Header{}
	dom.Render("app", header)
}
```

## üé® Fluent Builder API

The new fluent API allows chaining for concise, readable code:

```go
dom.Div().
	ID("container").
	Class("flex items-center").
	Append(
		dom.Button().
			Text("Click me").
			OnClick(handleClick),
	).
	Append(
		dom.Span().
			Text("Hello World"),
	).
	Render("app") // Terminal operation
```

**Available builders**: `Div()`, `Span()`, `Button()`, `H1()`, `H2()`, `H3()`, `P()`, `Ul()`, `Li()`, `Input()`, `Form()`, `A()`, `Img()`

## üîÑ Lifecycle Hooks

Components can implement optional lifecycle interfaces:

```go
type MyComponent struct {
	dom.BaseComponent
	data []string
}

// Called after component is mounted to DOM
func (c *MyComponent) OnMount() {
	c.data = fetchData()
	c.Update()
}

// Called after re-render (dom.Update)
func (c *MyComponent) OnUpdate() {
	fmt.Println("Component updated")
}

// Called before component is removed
func (c *MyComponent) OnUnmount() {
	// Cleanup resources
}
```

## üìù Component Interface

All components must implement:

```go
type Component interface {
	GetID() string
	SetID(string)
	RenderHTML() string  // OR Render() dom.Node
	Children() []Component
}
```

**Two rendering options**:
1. **`RenderHTML() string`** - For static components (smaller binary)
2. **`Render() dom.Node`** - For dynamic components (type-safe, composable)

Components can implement **either or both**. DOM checks `Render()` first, falls back to `RenderHTML()`.

## üéØ Hybrid Rendering Strategy

Choose the right rendering method for each component:

| Component Type | Method | Benefit |
|---------------|--------|---------|
| **Static** (no interactivity) | `RenderHTML() string` | Smaller binary, less overhead |
| **Dynamic** (interactive, state) | `Render() dom.Node` | Type-safe, composable, fluent API |

```go
// Static: Use string HTML
type Footer struct {
	dom.BaseComponent
}
func (f *Footer) RenderHTML() string {
	return `<footer>¬© 2026 My App</footer>`
}

// Dynamic: Use DSL Builder
type TodoList struct {
	dom.BaseComponent
	todos []string
}
func (t *TodoList) Render() dom.Node {
	list := dom.Ul().ID(t.GetID())
	for _, todo := range t.todos {
		list.Append(dom.Li().Text(todo))
	}
	return list.ToNode()
}
```

## üß© Nested Components

Components can contain child components:

```go
type MyList struct {
	dom.BaseComponent
	items []dom.Component
}

func (c *MyList) Children() []dom.Component {
	return c.items
}

func (c *MyList) Render() dom.Node {
	list := dom.Div().ID(c.GetID())
	for _, item := range c.items {
		list.Append(item) // Components can be children
	}
	return list.ToNode()
}
```

When you call `dom.Render("app", myList)`, the library will:
1. Render the HTML
2. Call `OnMount()` for `MyList`
3. Recursively call `OnMount()` for all `items`

The same recursion applies to `Unmount()`, ensuring all event listeners are cleaned up.

## üéØ Event Handling

```go
func (c *MyComponent) OnMount() {
	root, _ := dom.Get(c.GetID())

	// Event delegation using TargetID
	root.On("click", func(e dom.Event) {
		id := e.TargetID() // "item-1", "item-2", etc.
		// Handle logic...
	})
}
```

## üîß Core API

### Package Functions

```go
// Rendering
dom.Render(parentID, component)  // Replace parent's content
dom.Append(parentID, component)  // Append after last child
dom.Hydrate(parentID, component) // Attach to server-rendered HTML
dom.Update(component)            // Re-render in place

// Lifecycle
dom.Unmount(component)           // Remove and cleanup

// Element Access
dom.Get(id)                      // Get element by ID
dom.QueryAll(selector)           // Query by CSS selector

// Routing (hash-based)
dom.OnHashChange(handler)        // Listen to hash changes
dom.GetHash()                    // Get current hash
dom.SetHash(hash)                // Set hash
```

### BaseComponent Helpers

```go
type Counter struct {
	dom.BaseComponent
	count int
}

// Chainable helpers
counter.Update()              // Trigger re-render
counter.Unmount()             // Remove from DOM
counter.GetID()               // Get unique ID
counter.SetID("my-id")        // Set custom ID
```

## üìö Documentation

For more detailed information, please refer to the documentation in the `docs/` directory:

1.  **[Specification & Philosophy](docs/SPECIFICATION.md)**: Design goals, architecture, and key decisions.
2.  **[API Reference](docs/API.md)**: Detailed definition of `DOM`, `Element`, and `Component` interfaces.
3.  **[Creating Components](docs/COMPONENTS.md)**: Guide to building basic and nested components.
4.  **[Event Handling](docs/EVENTS.md)**: Using the `Event` interface for clicks, inputs, and forms.
5.  **[Advanced Patterns](docs/ADVANCED.md)**: Dynamic lists, decoupling, and performance tips.
6.  **[Comparison](docs/COMPARISON.md)**: TinyDOM vs. syscall/js, VDOM, and JS frameworks.

## üÜï What's New in v0.2.0

- ‚úÖ **Elm-inspired architecture** - Component-local state with explicit updates
- ‚úÖ **Fluent Builder API** - Chainable methods (`dom.Div().ID("x").Class("y")`)
- ‚úÖ **Hybrid rendering** - Choose DSL or string HTML per component
- ‚úÖ **Lifecycle hooks** - `OnMount`, `OnUpdate`, `OnUnmount`
- ‚úÖ **Auto-ID generation** - All components get unique IDs automatically
- ‚úÖ **Smaller binaries** - TinyGo-optimized, <500KB for typical apps

## üìä Performance

**Binary Size** (TinyGo WASM):
- Simple counter app: ~35KB (compressed)
- Todo list with 10 components: ~120KB (compressed)
- Full application: <500KB (compressed)

**Compared to standard library approach**: 60-80% smaller binaries.

## License

MIT
