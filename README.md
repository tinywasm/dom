# tinywasm/dom
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by devflow from github.com/tinywasm/devflow"></a>
<!-- END_SECTION:BADGES_SECTION -->

> **Ultra-minimal DOM & event toolkit for Go (TinyGo WASM-optimized).**

tinywasm/dom provides a minimalist, WASM-optimized way to interact with the browser DOM in Go, avoiding the overhead of the standard library and `syscall/js` exposure. It is designed specifically for **TinyGo** applications where binary size and performance are critical.

## ðŸš€ Features

*   **Elm-Inspired Architecture**: Component-local state with explicit updates (Model â†’ Update â†’ View)
*   **Fluent Builder API**: Chainable methods for concise, readable code
*   **Hybrid Rendering**: Choose DSL for dynamic components or string HTML for static ones
*   **TinyGo Optimized**: Avoids heavy standard library packages to keep WASM binaries <500KB
*   **Direct DOM Manipulation**: No Virtual DOM overhead. You control the updates.
*   **ID-Based Caching**: Efficient element lookup and caching strategy
*   **Lifecycle Hooks**: `OnMount`, `OnUpdate`, `OnUnmount` for fine-grained control

## ðŸ“¦ Installation

```bash
go get github.com/tinywasm/dom
```

## âš¡ Quick Start

For a complete example including Elm architecture (Dynamic Components) and Static Components, check the following file:

ðŸ‘‰ **[web/client.go](web/client.go)**

This file contains the reference implementation used for testing and demonstrations.

## ðŸŽ¨ Fluent Builder API

The new fluent API allows chaining for concise, readable code:

```go
dom.Div().
	ID("container").
	Class("flex items-center").
	Add(
		dom.Button().
			Text("Click me").
			On("click", handleClick),
		dom.Span().
			Text("Hello World"),
	).
	Render("app") // Terminal operation
```

**Available builders**: `Div()`, `Span()`, `Button()`, `H1()`, `H2()`, `H3()`, `P()`, `Ul()`, `Li()`, `Input()`, `Form()`, `A()`, `Img()`

## ðŸ”„ Lifecycle Hooks

Components can implement optional lifecycle interfaces:

```go
type MyComponent struct {
	*dom.Element
	data []string
}

// Called after component is mounted to DOM
func (c *MyComponent) OnMount() {
	c.data = fetchData()
	c.Update()
}

// Called after re-render (dom.Update)
func (c *MyComponent) OnUpdate() {
	fmt.Println("Component updated")
}

// Called before component is removed
func (c *MyComponent) OnUnmount() {
	// Cleanup resources
}
```

## ðŸ“ Component Interface

All components must implement:

```go
type Component interface {
	GetID() string
	SetID(string)
	RenderHTML() string  // OR Render() *Element
	Children() []Component
}
```

**Two rendering options**:
1. **`RenderHTML() string`** - For static components (smaller binary)
2. **`Render() *dom.Element`** - For dynamic components (type-safe, composable)

Components can implement **either or both**. DOM checks `Render()` first, falls back to `RenderHTML()`.

## ðŸŽ¯ Hybrid Rendering Strategy

Choose the right rendering method for each component:

| Component Type | Method | Benefit |
|---------------|--------|---------|
| **Static** (no interactivity) | `RenderHTML() string` | Smaller binary, less overhead |
| **Dynamic** (interactive, state) | `Render() *dom.Element` | Type-safe, composable, fluent API |

See the implementation examples in **[web/client.go](web/client.go)** to see both approaches in action.

## ðŸ§© Nested Components

Components can contain child components:

```go
type MyList struct {
	*dom.Element
	items []dom.Component
}

func (c *MyList) Children() []dom.Component {
	return c.items
}

func (c *MyList) Render() *dom.Element {
	list := dom.Div()
	for _, item := range c.items {
		list.Add(item) // Components can be children
	}
	return list
}
```

When you call `dom.Render("app", myList)`, the library will:
1. Render the HTML
2. Call `OnMount()` for `MyList`
3. Recursively call `OnMount()` for all `items`

The same recursion applies to cleanup, ensuring all event listeners are cleaned up when a parent is replaced.

## ðŸŽ¯ Event Handling

Event handling is integrated directly into the Builder API via `On(eventType, handler)`.


## ðŸ”§ Core API

### Package Functions

```go
// Rendering
dom.Render(parentID, component)  // Replace parent's content
dom.Append(parentID, component)  // Append after last child
dom.Update(component)            // Re-render in place

// Routing (hash-based)
dom.OnHashChange(handler)        // Listen to hash changes
dom.GetHash()                    // Get current hash
dom.SetHash(hash)                // Set hash
```

### Element Helpers

Embedding `*dom.Element` provides these methods automatically:

```go
type Counter struct {
	*dom.Element
	count int
}

// Chainable helpers
counter.Update()              // Trigger re-render
counter.GetID()               // Get unique ID
counter.SetID("my-id")        // Set custom ID
```

## ðŸ“š Documentation

For more detailed information, please refer to the documentation in the `docs/` directory:

1.  **[Specification & Philosophy](docs/SPECIFICATION.md)**: Design goals, architecture, and key decisions.
2.  **[API Reference](docs/API.md)**: Detailed definition of `DOM`, `Element`, and `Component` interfaces.
3.  **[Creating Components](docs/COMPONENTS.md)**: Guide to building basic and nested components.
4.  **[Event Handling](docs/EVENTS.md)**: Using the `Event` interface for clicks, inputs, and forms.
5.  **[Advanced Patterns](docs/ADVANCED.md)**: Dynamic lists, decoupling, and performance tips.
6.  **[Comparison](docs/COMPARISON.md)**: TinyDOM vs. syscall/js, VDOM, and JS frameworks.

## ðŸ†• What's New in v0.2.0

- âœ… **Elm-inspired architecture** - Component-local state with explicit updates
- âœ… **Fluent Builder API** - Chainable methods (`dom.Div().ID("x").Class("y")`)
- âœ… **Hybrid rendering** - Choose DSL or string HTML per component
- âœ… **Lifecycle hooks** - `OnMount`, `OnUpdate`, `OnUnmount`
- âœ… **Auto-ID generation** - All components get unique IDs automatically
- âœ… **Smaller binaries** - TinyGo-optimized, <500KB for typical apps

## ðŸ“Š Performance

**Binary Size** (TinyGo WASM):
- Simple counter app: ~35KB (compressed)
- Todo list with 10 components: ~120KB (compressed)
- Full application: <500KB (compressed)

**Compared to standard library approach**: 60-80% smaller binaries.

## License

MIT
